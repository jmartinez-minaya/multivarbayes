---
title: "Multivariate linear regression"
author: "Joaquín Martínez-Minaya"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multivariate linear regression}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview

This vignette demonstrates how to use the **multivarbayes** package to fit a Bayesian multivariate linear regression model, summarize the results, plot the posterior distributions, and make predictions on new data.

### Example Usage

```{r setup, include=FALSE}
library(multivarbayes)
```

### Generate Example Data

We generate some example data with an intercept term and multivariate normal errors.

```{r, warning=FALSE, message = FALSE}
 library(ggplot2) # for plotting
library(dplyr)

set.seed(123)
n <- 1000  # number of observations
k <- 3    # number of covariates (including intercept)
m <- 2    # number of response variables
nsims <- 1000

# Covariate matrix with intercept
X <- cbind(1, matrix(rnorm(n * (k - 1)), n, k - 1))  

# True coefficients
B_true <- matrix(c(1, 0.5, -0.3, 2, -0.5, 1), ncol = m)

# Multivariate normal errors
Sigma_true <- matrix(c(1, 0.3, 0.3, 1), ncol = m)
errors <- MASS::mvrnorm(n, mu = rep(0, m), Sigma = Sigma_true)

# Response matrix
Y <- X %*% B_true + errors  

# Combine into data frame
data <- data.frame(cbind(Y, X))
colnames(data) <- c("Y1", "Y2", "Intercept", "X1", "X2")
```

### Fit the Model

We fit the model using the `mlvr` function and the formula interface.

```{r}
formula <- as.matrix(data[, c("Y1", "Y2")]) ~  X1 + X2
model_fit <- mlvr(formula, data = data)
model_fit$analytic
```

### Summarize the Fitted Model

We can summarize the fitted model to inspect the posterior distributions of the coefficients and the scale matrix of Sigma.

```{r}
summary(model_fit)
```

### Plot Posterior Distributions

To visualize the posterior distributions of the coefficients, we can use the `plot` method.

```{r}
plot(model_fit)

```


```{r}
summary(model_fit)
B_true
```


### Predict New Observations

Finally, we can use the `predict` function to predict responses for new observations based on the fitted model.

```{r}

# Example usage:
# Assuming model_fit is the fitted object and newdata is the new data to predict on
newdata <- data.frame(X1 = c(0.5, -1, 2), X2 = c(-0.5, 1.5, 0))  # New covariate values
newdata <- data[1:5, c("X1", "X2")]
newdata_real <- data[1:5, c("Y1", "Y2")]

predictions <- predict(model_fit, newdata = newdata)

predictions$summary
predictions$marginals$Y1 %>% dim(.)
```





```{r}
# Supongamos que `predictions` es el objeto con los resultados obtenidos de la función `predict.mlvr`
# y `newdata_real` contiene los valores reales para cada individuo predicho.

library(ggplot2)
library(dplyr)
library(tidyr)

# Extraer los elementos necesarios de predictions
analytic_mean <- predictions$analytic$mean          # Media predictiva teórica
analytic_cov <- predictions$analytic$cov_matrix     # Covarianza predictiva teórica
predictive_samples <- predictions$marginals         # Muestras predictivas simuladas
df <- predictions$analytic$df                       # Grados de libertad para la t-Student
newdata_real <- newdata_real                        # Valores reales proporcionados

# Crear un data frame para almacenar las muestras predictivas simuladas
simulated_data <- data.frame()
n_obs <- nrow(analytic_mean)                        # Número de observaciones en newdata
n_sims <- ncol(predictive_samples[[1]])             # Número de simulaciones (suponemos que todas las respuestas tienen el mismo número de simulaciones)
n_responses <- length(predictive_samples)           # Número de variables de respuesta

# Construir el data frame de muestras predictivas simuladas
for (resp in 1:n_responses) {
  for (obs in 1:n_obs) {
    sim_values <- predictive_samples[[resp]][obs, ]  # Muestras simuladas para la variable de respuesta y observación
    sim_df <- data.frame(
      Observation = paste0("Obs_", obs),             # Etiqueta de observación
      Response = paste0("Y", resp),                  # Nombre de la variable de respuesta
      Value = sim_values,                            # Muestras simuladas
      Group = "Simulated"                            # Etiqueta de grupo
    )
    simulated_data <- rbind(simulated_data, sim_df)
  }
}

# Crear un data frame para las densidades teóricas
theoretical_data <- data.frame()

# Calcular la densidad teórica para cada observación y variable de respuesta
for (obs in 1:n_obs) {
  for (resp in 1:n_responses) {
    mean_val <- analytic_mean[obs, resp]          # Media teórica para la variable de respuesta
    var_val <- analytic_cov[resp, resp, obs]      # Varianza para la variable de respuesta
    
    # Crear secuencia de valores para representar la densidad teórica
    x_vals <- seq(mean_val - 4 * sqrt(var_val), mean_val + 4 * sqrt(var_val), length.out = 500)
    
    # Calcular la densidad usando la distribución t-Student
    dens_vals <- dt((x_vals - mean_val) / sqrt(var_val), df = df) / sqrt(var_val)
    
    # Crear data frame para almacenar las densidades teóricas
    theor_df <- data.frame(
      Observation = paste0("Obs_", obs),
      Response = paste0("Y", resp),
      Value = x_vals,
      Density = dens_vals,
      Group = "Theoretical"
    )
    theoretical_data <- rbind(theoretical_data, theor_df)
  }
}

# Crear el data frame para los valores reales observados
real_values_data <- data.frame(
  Observation = rep(paste0("Obs_", 1:n_obs), each = n_responses),  # Observaciones etiquetadas
  Response = rep(paste0("Y", 1:n_responses), times = n_obs),       # Nombre de la variable de respuesta
  Value = as.vector(t(newdata_real)),                              # Convertir los valores reales a un vector
  Group = "Real"                                                   # Etiqueta de grupo para "Real"
)

# Convertir los datos simulados a densidades para graficar
simulated_densities <- simulated_data %>%
  group_by(Observation, Response) %>%
  do({
    density_data <- density(.$Value, adjust = 1.2)  # Calcular densidad para las muestras simuladas
    data.frame(Value = density_data$x, Density = density_data$y)  # Almacenar valores de densidad
  }) %>%
  ungroup() %>%
  mutate(Group = "Simulated")  # Etiqueta como "Simulated" para graficar

# Unir las densidades teóricas y simuladas en un solo data frame
plot_data <- rbind(simulated_densities, theoretical_data)

# Crear los gráficos
ggplot() +
  # Histogramas para las muestras predictivas simuladas
  geom_line(data = simulated_densities, aes(x = Value, y = Density, color = Group), size = 1.2) +
  # Línea para las densidades teóricas
  geom_line(data = theoretical_data, aes(x = Value, y = Density, color = Group), linetype = "dashed", size = 1.2) +
  # Línea vertical para los valores reales observados
  geom_vline(data = real_values_data, aes(xintercept = Value, color = Group), linetype = "dotted", size = 1.2) +
  facet_grid(Response ~ Observation, scales = "free") +  # Subgráficos por respuesta y observación
  labs(title = "Predictive Distributions for Each Observation",
       x = "Value",
       y = "Density") +
  theme_minimal() +
  theme(legend.position = "top", legend.title = element_text(face = "bold")) +
  scale_color_manual(values = c("blue", "red", "green")) +   # Colores para las distribuciones y valores reales
  guides(color = guide_legend(title = "Distribution Types"))


```


